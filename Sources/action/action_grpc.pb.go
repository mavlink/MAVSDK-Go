// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: action.proto

package action

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ActionService_Arm_FullMethodName                       = "/mavsdk.rpc.action.ActionService/Arm"
	ActionService_ArmForce_FullMethodName                  = "/mavsdk.rpc.action.ActionService/ArmForce"
	ActionService_Disarm_FullMethodName                    = "/mavsdk.rpc.action.ActionService/Disarm"
	ActionService_Takeoff_FullMethodName                   = "/mavsdk.rpc.action.ActionService/Takeoff"
	ActionService_Land_FullMethodName                      = "/mavsdk.rpc.action.ActionService/Land"
	ActionService_Reboot_FullMethodName                    = "/mavsdk.rpc.action.ActionService/Reboot"
	ActionService_Shutdown_FullMethodName                  = "/mavsdk.rpc.action.ActionService/Shutdown"
	ActionService_Terminate_FullMethodName                 = "/mavsdk.rpc.action.ActionService/Terminate"
	ActionService_Kill_FullMethodName                      = "/mavsdk.rpc.action.ActionService/Kill"
	ActionService_ReturnToLaunch_FullMethodName            = "/mavsdk.rpc.action.ActionService/ReturnToLaunch"
	ActionService_GotoLocation_FullMethodName              = "/mavsdk.rpc.action.ActionService/GotoLocation"
	ActionService_DoOrbit_FullMethodName                   = "/mavsdk.rpc.action.ActionService/DoOrbit"
	ActionService_Hold_FullMethodName                      = "/mavsdk.rpc.action.ActionService/Hold"
	ActionService_SetActuator_FullMethodName               = "/mavsdk.rpc.action.ActionService/SetActuator"
	ActionService_TransitionToFixedwing_FullMethodName     = "/mavsdk.rpc.action.ActionService/TransitionToFixedwing"
	ActionService_TransitionToMulticopter_FullMethodName   = "/mavsdk.rpc.action.ActionService/TransitionToMulticopter"
	ActionService_GetTakeoffAltitude_FullMethodName        = "/mavsdk.rpc.action.ActionService/GetTakeoffAltitude"
	ActionService_SetTakeoffAltitude_FullMethodName        = "/mavsdk.rpc.action.ActionService/SetTakeoffAltitude"
	ActionService_GetReturnToLaunchAltitude_FullMethodName = "/mavsdk.rpc.action.ActionService/GetReturnToLaunchAltitude"
	ActionService_SetReturnToLaunchAltitude_FullMethodName = "/mavsdk.rpc.action.ActionService/SetReturnToLaunchAltitude"
	ActionService_SetCurrentSpeed_FullMethodName           = "/mavsdk.rpc.action.ActionService/SetCurrentSpeed"
)

// ActionServiceClient is the client API for ActionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Enable simple actions such as arming, taking off, and landing.
type ActionServiceClient interface {
	// Send command to arm the drone.
	//
	// Arming a drone normally causes motors to spin at idle.
	// Before arming take all safety precautions and stand clear of the drone!
	Arm(ctx context.Context, in *ArmRequest, opts ...grpc.CallOption) (*ArmResponse, error)
	// Send command to force-arm the drone without any checks.
	//
	// Attention: this is not to be used for normal flying but only bench tests!
	//
	// Arming a drone normally causes motors to spin at idle.
	// Before arming take all safety precautions and stand clear of the drone!
	ArmForce(ctx context.Context, in *ArmForceRequest, opts ...grpc.CallOption) (*ArmForceResponse, error)
	// Send command to disarm the drone.
	//
	// This will disarm a drone that considers itself landed. If flying, the drone should
	// reject the disarm command. Disarming means that all motors will stop.
	Disarm(ctx context.Context, in *DisarmRequest, opts ...grpc.CallOption) (*DisarmResponse, error)
	// Send command to take off and hover.
	//
	// This switches the drone into position control mode and commands
	// it to take off and hover at the takeoff altitude.
	//
	// Note that the vehicle must be armed before it can take off.
	Takeoff(ctx context.Context, in *TakeoffRequest, opts ...grpc.CallOption) (*TakeoffResponse, error)
	// Send command to land at the current position.
	//
	// This switches the drone to 'Land' flight mode.
	Land(ctx context.Context, in *LandRequest, opts ...grpc.CallOption) (*LandResponse, error)
	// Send command to reboot the drone components.
	//
	// This will reboot the autopilot, companion computer, camera and gimbal.
	Reboot(ctx context.Context, in *RebootRequest, opts ...grpc.CallOption) (*RebootResponse, error)
	// Send command to shut down the drone components.
	//
	// This will shut down the autopilot, onboard computer, camera and gimbal.
	// This command should only be used when the autopilot is disarmed and autopilots commonly
	// reject it if they are not already ready to shut down.
	Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error)
	// Send command to terminate the drone.
	//
	// This will run the terminate routine as configured on the drone (e.g. disarm and open the parachute).
	Terminate(ctx context.Context, in *TerminateRequest, opts ...grpc.CallOption) (*TerminateResponse, error)
	// Send command to kill the drone.
	//
	// This will disarm a drone irrespective of whether it is landed or flying.
	// Note that the drone will fall out of the sky if this command is used while flying.
	Kill(ctx context.Context, in *KillRequest, opts ...grpc.CallOption) (*KillResponse, error)
	// Send command to return to the launch (takeoff) position and land.
	//
	// This switches the drone into [Return mode](https://docs.px4.io/master/en/flight_modes/return.html) which
	// generally means it will rise up to a certain altitude to clear any obstacles before heading
	// back to the launch (takeoff) position and land there.
	ReturnToLaunch(ctx context.Context, in *ReturnToLaunchRequest, opts ...grpc.CallOption) (*ReturnToLaunchResponse, error)
	// Send command to move the vehicle to a specific global position.
	//
	// The latitude and longitude are given in degrees (WGS84 frame) and the altitude
	// in meters AMSL (above mean sea level).
	//
	// The yaw angle is in degrees (frame is NED, 0 is North, positive is clockwise).
	GotoLocation(ctx context.Context, in *GotoLocationRequest, opts ...grpc.CallOption) (*GotoLocationResponse, error)
	// Send command do orbit to the drone.
	//
	// This will run the orbit routine with the given parameters.
	DoOrbit(ctx context.Context, in *DoOrbitRequest, opts ...grpc.CallOption) (*DoOrbitResponse, error)
	// Send command to hold position (a.k.a. "Loiter").
	//
	// Sends a command to drone to change to Hold flight mode, causing the
	// vehicle to stop and maintain its current GPS position and altitude.
	//
	// Note: this command is specific to the PX4 Autopilot flight stack as
	// it implies a change to a PX4-specific mode.
	Hold(ctx context.Context, in *HoldRequest, opts ...grpc.CallOption) (*HoldResponse, error)
	// Send command to set the value of an actuator.
	//
	// Note that the index of the actuator starts at 1 and that the value goes from -1 to 1.
	SetActuator(ctx context.Context, in *SetActuatorRequest, opts ...grpc.CallOption) (*SetActuatorResponse, error)
	// Send command to transition the drone to fixedwing.
	//
	// The associated action will only be executed for VTOL vehicles (on other vehicle types the
	// command will fail). The command will succeed if called when the vehicle
	// is already in fixedwing mode.
	TransitionToFixedwing(ctx context.Context, in *TransitionToFixedwingRequest, opts ...grpc.CallOption) (*TransitionToFixedwingResponse, error)
	// Send command to transition the drone to multicopter.
	//
	// The associated action will only be executed for VTOL vehicles (on other vehicle types the
	// command will fail). The command will succeed if called when the vehicle
	// is already in multicopter mode.
	TransitionToMulticopter(ctx context.Context, in *TransitionToMulticopterRequest, opts ...grpc.CallOption) (*TransitionToMulticopterResponse, error)
	// Get the takeoff altitude (in meters above ground).
	GetTakeoffAltitude(ctx context.Context, in *GetTakeoffAltitudeRequest, opts ...grpc.CallOption) (*GetTakeoffAltitudeResponse, error)
	// Set takeoff altitude (in meters above ground).
	SetTakeoffAltitude(ctx context.Context, in *SetTakeoffAltitudeRequest, opts ...grpc.CallOption) (*SetTakeoffAltitudeResponse, error)
	// Get the return to launch minimum return altitude (in meters).
	GetReturnToLaunchAltitude(ctx context.Context, in *GetReturnToLaunchAltitudeRequest, opts ...grpc.CallOption) (*GetReturnToLaunchAltitudeResponse, error)
	// Set the return to launch minimum return altitude (in meters).
	SetReturnToLaunchAltitude(ctx context.Context, in *SetReturnToLaunchAltitudeRequest, opts ...grpc.CallOption) (*SetReturnToLaunchAltitudeResponse, error)
	// Set current speed.
	//
	// This will set the speed during a mission, reposition, and similar.
	// It is ephemeral, so not stored on the drone and does not survive a reboot.
	SetCurrentSpeed(ctx context.Context, in *SetCurrentSpeedRequest, opts ...grpc.CallOption) (*SetCurrentSpeedResponse, error)
}

type actionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewActionServiceClient(cc grpc.ClientConnInterface) ActionServiceClient {
	return &actionServiceClient{cc}
}

func (c *actionServiceClient) Arm(ctx context.Context, in *ArmRequest, opts ...grpc.CallOption) (*ArmResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArmResponse)
	err := c.cc.Invoke(ctx, ActionService_Arm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) ArmForce(ctx context.Context, in *ArmForceRequest, opts ...grpc.CallOption) (*ArmForceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArmForceResponse)
	err := c.cc.Invoke(ctx, ActionService_ArmForce_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) Disarm(ctx context.Context, in *DisarmRequest, opts ...grpc.CallOption) (*DisarmResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisarmResponse)
	err := c.cc.Invoke(ctx, ActionService_Disarm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) Takeoff(ctx context.Context, in *TakeoffRequest, opts ...grpc.CallOption) (*TakeoffResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TakeoffResponse)
	err := c.cc.Invoke(ctx, ActionService_Takeoff_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) Land(ctx context.Context, in *LandRequest, opts ...grpc.CallOption) (*LandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LandResponse)
	err := c.cc.Invoke(ctx, ActionService_Land_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) Reboot(ctx context.Context, in *RebootRequest, opts ...grpc.CallOption) (*RebootResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RebootResponse)
	err := c.cc.Invoke(ctx, ActionService_Reboot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShutdownResponse)
	err := c.cc.Invoke(ctx, ActionService_Shutdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) Terminate(ctx context.Context, in *TerminateRequest, opts ...grpc.CallOption) (*TerminateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TerminateResponse)
	err := c.cc.Invoke(ctx, ActionService_Terminate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) Kill(ctx context.Context, in *KillRequest, opts ...grpc.CallOption) (*KillResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KillResponse)
	err := c.cc.Invoke(ctx, ActionService_Kill_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) ReturnToLaunch(ctx context.Context, in *ReturnToLaunchRequest, opts ...grpc.CallOption) (*ReturnToLaunchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReturnToLaunchResponse)
	err := c.cc.Invoke(ctx, ActionService_ReturnToLaunch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) GotoLocation(ctx context.Context, in *GotoLocationRequest, opts ...grpc.CallOption) (*GotoLocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GotoLocationResponse)
	err := c.cc.Invoke(ctx, ActionService_GotoLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) DoOrbit(ctx context.Context, in *DoOrbitRequest, opts ...grpc.CallOption) (*DoOrbitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DoOrbitResponse)
	err := c.cc.Invoke(ctx, ActionService_DoOrbit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) Hold(ctx context.Context, in *HoldRequest, opts ...grpc.CallOption) (*HoldResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HoldResponse)
	err := c.cc.Invoke(ctx, ActionService_Hold_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) SetActuator(ctx context.Context, in *SetActuatorRequest, opts ...grpc.CallOption) (*SetActuatorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetActuatorResponse)
	err := c.cc.Invoke(ctx, ActionService_SetActuator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) TransitionToFixedwing(ctx context.Context, in *TransitionToFixedwingRequest, opts ...grpc.CallOption) (*TransitionToFixedwingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransitionToFixedwingResponse)
	err := c.cc.Invoke(ctx, ActionService_TransitionToFixedwing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) TransitionToMulticopter(ctx context.Context, in *TransitionToMulticopterRequest, opts ...grpc.CallOption) (*TransitionToMulticopterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransitionToMulticopterResponse)
	err := c.cc.Invoke(ctx, ActionService_TransitionToMulticopter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) GetTakeoffAltitude(ctx context.Context, in *GetTakeoffAltitudeRequest, opts ...grpc.CallOption) (*GetTakeoffAltitudeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTakeoffAltitudeResponse)
	err := c.cc.Invoke(ctx, ActionService_GetTakeoffAltitude_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) SetTakeoffAltitude(ctx context.Context, in *SetTakeoffAltitudeRequest, opts ...grpc.CallOption) (*SetTakeoffAltitudeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetTakeoffAltitudeResponse)
	err := c.cc.Invoke(ctx, ActionService_SetTakeoffAltitude_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) GetReturnToLaunchAltitude(ctx context.Context, in *GetReturnToLaunchAltitudeRequest, opts ...grpc.CallOption) (*GetReturnToLaunchAltitudeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetReturnToLaunchAltitudeResponse)
	err := c.cc.Invoke(ctx, ActionService_GetReturnToLaunchAltitude_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) SetReturnToLaunchAltitude(ctx context.Context, in *SetReturnToLaunchAltitudeRequest, opts ...grpc.CallOption) (*SetReturnToLaunchAltitudeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetReturnToLaunchAltitudeResponse)
	err := c.cc.Invoke(ctx, ActionService_SetReturnToLaunchAltitude_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionServiceClient) SetCurrentSpeed(ctx context.Context, in *SetCurrentSpeedRequest, opts ...grpc.CallOption) (*SetCurrentSpeedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetCurrentSpeedResponse)
	err := c.cc.Invoke(ctx, ActionService_SetCurrentSpeed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ActionServiceServer is the server API for ActionService service.
// All implementations must embed UnimplementedActionServiceServer
// for forward compatibility.
//
// Enable simple actions such as arming, taking off, and landing.
type ActionServiceServer interface {
	// Send command to arm the drone.
	//
	// Arming a drone normally causes motors to spin at idle.
	// Before arming take all safety precautions and stand clear of the drone!
	Arm(context.Context, *ArmRequest) (*ArmResponse, error)
	// Send command to force-arm the drone without any checks.
	//
	// Attention: this is not to be used for normal flying but only bench tests!
	//
	// Arming a drone normally causes motors to spin at idle.
	// Before arming take all safety precautions and stand clear of the drone!
	ArmForce(context.Context, *ArmForceRequest) (*ArmForceResponse, error)
	// Send command to disarm the drone.
	//
	// This will disarm a drone that considers itself landed. If flying, the drone should
	// reject the disarm command. Disarming means that all motors will stop.
	Disarm(context.Context, *DisarmRequest) (*DisarmResponse, error)
	// Send command to take off and hover.
	//
	// This switches the drone into position control mode and commands
	// it to take off and hover at the takeoff altitude.
	//
	// Note that the vehicle must be armed before it can take off.
	Takeoff(context.Context, *TakeoffRequest) (*TakeoffResponse, error)
	// Send command to land at the current position.
	//
	// This switches the drone to 'Land' flight mode.
	Land(context.Context, *LandRequest) (*LandResponse, error)
	// Send command to reboot the drone components.
	//
	// This will reboot the autopilot, companion computer, camera and gimbal.
	Reboot(context.Context, *RebootRequest) (*RebootResponse, error)
	// Send command to shut down the drone components.
	//
	// This will shut down the autopilot, onboard computer, camera and gimbal.
	// This command should only be used when the autopilot is disarmed and autopilots commonly
	// reject it if they are not already ready to shut down.
	Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error)
	// Send command to terminate the drone.
	//
	// This will run the terminate routine as configured on the drone (e.g. disarm and open the parachute).
	Terminate(context.Context, *TerminateRequest) (*TerminateResponse, error)
	// Send command to kill the drone.
	//
	// This will disarm a drone irrespective of whether it is landed or flying.
	// Note that the drone will fall out of the sky if this command is used while flying.
	Kill(context.Context, *KillRequest) (*KillResponse, error)
	// Send command to return to the launch (takeoff) position and land.
	//
	// This switches the drone into [Return mode](https://docs.px4.io/master/en/flight_modes/return.html) which
	// generally means it will rise up to a certain altitude to clear any obstacles before heading
	// back to the launch (takeoff) position and land there.
	ReturnToLaunch(context.Context, *ReturnToLaunchRequest) (*ReturnToLaunchResponse, error)
	// Send command to move the vehicle to a specific global position.
	//
	// The latitude and longitude are given in degrees (WGS84 frame) and the altitude
	// in meters AMSL (above mean sea level).
	//
	// The yaw angle is in degrees (frame is NED, 0 is North, positive is clockwise).
	GotoLocation(context.Context, *GotoLocationRequest) (*GotoLocationResponse, error)
	// Send command do orbit to the drone.
	//
	// This will run the orbit routine with the given parameters.
	DoOrbit(context.Context, *DoOrbitRequest) (*DoOrbitResponse, error)
	// Send command to hold position (a.k.a. "Loiter").
	//
	// Sends a command to drone to change to Hold flight mode, causing the
	// vehicle to stop and maintain its current GPS position and altitude.
	//
	// Note: this command is specific to the PX4 Autopilot flight stack as
	// it implies a change to a PX4-specific mode.
	Hold(context.Context, *HoldRequest) (*HoldResponse, error)
	// Send command to set the value of an actuator.
	//
	// Note that the index of the actuator starts at 1 and that the value goes from -1 to 1.
	SetActuator(context.Context, *SetActuatorRequest) (*SetActuatorResponse, error)
	// Send command to transition the drone to fixedwing.
	//
	// The associated action will only be executed for VTOL vehicles (on other vehicle types the
	// command will fail). The command will succeed if called when the vehicle
	// is already in fixedwing mode.
	TransitionToFixedwing(context.Context, *TransitionToFixedwingRequest) (*TransitionToFixedwingResponse, error)
	// Send command to transition the drone to multicopter.
	//
	// The associated action will only be executed for VTOL vehicles (on other vehicle types the
	// command will fail). The command will succeed if called when the vehicle
	// is already in multicopter mode.
	TransitionToMulticopter(context.Context, *TransitionToMulticopterRequest) (*TransitionToMulticopterResponse, error)
	// Get the takeoff altitude (in meters above ground).
	GetTakeoffAltitude(context.Context, *GetTakeoffAltitudeRequest) (*GetTakeoffAltitudeResponse, error)
	// Set takeoff altitude (in meters above ground).
	SetTakeoffAltitude(context.Context, *SetTakeoffAltitudeRequest) (*SetTakeoffAltitudeResponse, error)
	// Get the return to launch minimum return altitude (in meters).
	GetReturnToLaunchAltitude(context.Context, *GetReturnToLaunchAltitudeRequest) (*GetReturnToLaunchAltitudeResponse, error)
	// Set the return to launch minimum return altitude (in meters).
	SetReturnToLaunchAltitude(context.Context, *SetReturnToLaunchAltitudeRequest) (*SetReturnToLaunchAltitudeResponse, error)
	// Set current speed.
	//
	// This will set the speed during a mission, reposition, and similar.
	// It is ephemeral, so not stored on the drone and does not survive a reboot.
	SetCurrentSpeed(context.Context, *SetCurrentSpeedRequest) (*SetCurrentSpeedResponse, error)
	mustEmbedUnimplementedActionServiceServer()
}

// UnimplementedActionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedActionServiceServer struct{}

func (UnimplementedActionServiceServer) Arm(context.Context, *ArmRequest) (*ArmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Arm not implemented")
}
func (UnimplementedActionServiceServer) ArmForce(context.Context, *ArmForceRequest) (*ArmForceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArmForce not implemented")
}
func (UnimplementedActionServiceServer) Disarm(context.Context, *DisarmRequest) (*DisarmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disarm not implemented")
}
func (UnimplementedActionServiceServer) Takeoff(context.Context, *TakeoffRequest) (*TakeoffResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Takeoff not implemented")
}
func (UnimplementedActionServiceServer) Land(context.Context, *LandRequest) (*LandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Land not implemented")
}
func (UnimplementedActionServiceServer) Reboot(context.Context, *RebootRequest) (*RebootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reboot not implemented")
}
func (UnimplementedActionServiceServer) Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shutdown not implemented")
}
func (UnimplementedActionServiceServer) Terminate(context.Context, *TerminateRequest) (*TerminateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Terminate not implemented")
}
func (UnimplementedActionServiceServer) Kill(context.Context, *KillRequest) (*KillResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Kill not implemented")
}
func (UnimplementedActionServiceServer) ReturnToLaunch(context.Context, *ReturnToLaunchRequest) (*ReturnToLaunchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReturnToLaunch not implemented")
}
func (UnimplementedActionServiceServer) GotoLocation(context.Context, *GotoLocationRequest) (*GotoLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GotoLocation not implemented")
}
func (UnimplementedActionServiceServer) DoOrbit(context.Context, *DoOrbitRequest) (*DoOrbitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DoOrbit not implemented")
}
func (UnimplementedActionServiceServer) Hold(context.Context, *HoldRequest) (*HoldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Hold not implemented")
}
func (UnimplementedActionServiceServer) SetActuator(context.Context, *SetActuatorRequest) (*SetActuatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetActuator not implemented")
}
func (UnimplementedActionServiceServer) TransitionToFixedwing(context.Context, *TransitionToFixedwingRequest) (*TransitionToFixedwingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransitionToFixedwing not implemented")
}
func (UnimplementedActionServiceServer) TransitionToMulticopter(context.Context, *TransitionToMulticopterRequest) (*TransitionToMulticopterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransitionToMulticopter not implemented")
}
func (UnimplementedActionServiceServer) GetTakeoffAltitude(context.Context, *GetTakeoffAltitudeRequest) (*GetTakeoffAltitudeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTakeoffAltitude not implemented")
}
func (UnimplementedActionServiceServer) SetTakeoffAltitude(context.Context, *SetTakeoffAltitudeRequest) (*SetTakeoffAltitudeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTakeoffAltitude not implemented")
}
func (UnimplementedActionServiceServer) GetReturnToLaunchAltitude(context.Context, *GetReturnToLaunchAltitudeRequest) (*GetReturnToLaunchAltitudeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReturnToLaunchAltitude not implemented")
}
func (UnimplementedActionServiceServer) SetReturnToLaunchAltitude(context.Context, *SetReturnToLaunchAltitudeRequest) (*SetReturnToLaunchAltitudeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetReturnToLaunchAltitude not implemented")
}
func (UnimplementedActionServiceServer) SetCurrentSpeed(context.Context, *SetCurrentSpeedRequest) (*SetCurrentSpeedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCurrentSpeed not implemented")
}
func (UnimplementedActionServiceServer) mustEmbedUnimplementedActionServiceServer() {}
func (UnimplementedActionServiceServer) testEmbeddedByValue()                       {}

// UnsafeActionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ActionServiceServer will
// result in compilation errors.
type UnsafeActionServiceServer interface {
	mustEmbedUnimplementedActionServiceServer()
}

func RegisterActionServiceServer(s grpc.ServiceRegistrar, srv ActionServiceServer) {
	// If the following call pancis, it indicates UnimplementedActionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ActionService_ServiceDesc, srv)
}

func _ActionService_Arm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).Arm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_Arm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).Arm(ctx, req.(*ArmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_ArmForce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmForceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).ArmForce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_ArmForce_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).ArmForce(ctx, req.(*ArmForceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_Disarm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisarmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).Disarm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_Disarm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).Disarm(ctx, req.(*DisarmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_Takeoff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TakeoffRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).Takeoff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_Takeoff_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).Takeoff(ctx, req.(*TakeoffRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_Land_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).Land(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_Land_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).Land(ctx, req.(*LandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_Reboot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).Reboot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_Reboot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).Reboot(ctx, req.(*RebootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_Shutdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).Shutdown(ctx, req.(*ShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_Terminate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).Terminate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_Terminate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).Terminate(ctx, req.(*TerminateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_Kill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).Kill(ctx, req.(*KillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_ReturnToLaunch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReturnToLaunchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).ReturnToLaunch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_ReturnToLaunch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).ReturnToLaunch(ctx, req.(*ReturnToLaunchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_GotoLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GotoLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).GotoLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_GotoLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).GotoLocation(ctx, req.(*GotoLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_DoOrbit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoOrbitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).DoOrbit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_DoOrbit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).DoOrbit(ctx, req.(*DoOrbitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_Hold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HoldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).Hold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_Hold_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).Hold(ctx, req.(*HoldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_SetActuator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetActuatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).SetActuator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_SetActuator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).SetActuator(ctx, req.(*SetActuatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_TransitionToFixedwing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransitionToFixedwingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).TransitionToFixedwing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_TransitionToFixedwing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).TransitionToFixedwing(ctx, req.(*TransitionToFixedwingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_TransitionToMulticopter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransitionToMulticopterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).TransitionToMulticopter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_TransitionToMulticopter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).TransitionToMulticopter(ctx, req.(*TransitionToMulticopterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_GetTakeoffAltitude_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTakeoffAltitudeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).GetTakeoffAltitude(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_GetTakeoffAltitude_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).GetTakeoffAltitude(ctx, req.(*GetTakeoffAltitudeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_SetTakeoffAltitude_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTakeoffAltitudeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).SetTakeoffAltitude(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_SetTakeoffAltitude_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).SetTakeoffAltitude(ctx, req.(*SetTakeoffAltitudeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_GetReturnToLaunchAltitude_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReturnToLaunchAltitudeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).GetReturnToLaunchAltitude(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_GetReturnToLaunchAltitude_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).GetReturnToLaunchAltitude(ctx, req.(*GetReturnToLaunchAltitudeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_SetReturnToLaunchAltitude_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetReturnToLaunchAltitudeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).SetReturnToLaunchAltitude(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_SetReturnToLaunchAltitude_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).SetReturnToLaunchAltitude(ctx, req.(*SetReturnToLaunchAltitudeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionService_SetCurrentSpeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCurrentSpeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionServiceServer).SetCurrentSpeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActionService_SetCurrentSpeed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionServiceServer).SetCurrentSpeed(ctx, req.(*SetCurrentSpeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ActionService_ServiceDesc is the grpc.ServiceDesc for ActionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ActionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mavsdk.rpc.action.ActionService",
	HandlerType: (*ActionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Arm",
			Handler:    _ActionService_Arm_Handler,
		},
		{
			MethodName: "ArmForce",
			Handler:    _ActionService_ArmForce_Handler,
		},
		{
			MethodName: "Disarm",
			Handler:    _ActionService_Disarm_Handler,
		},
		{
			MethodName: "Takeoff",
			Handler:    _ActionService_Takeoff_Handler,
		},
		{
			MethodName: "Land",
			Handler:    _ActionService_Land_Handler,
		},
		{
			MethodName: "Reboot",
			Handler:    _ActionService_Reboot_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _ActionService_Shutdown_Handler,
		},
		{
			MethodName: "Terminate",
			Handler:    _ActionService_Terminate_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _ActionService_Kill_Handler,
		},
		{
			MethodName: "ReturnToLaunch",
			Handler:    _ActionService_ReturnToLaunch_Handler,
		},
		{
			MethodName: "GotoLocation",
			Handler:    _ActionService_GotoLocation_Handler,
		},
		{
			MethodName: "DoOrbit",
			Handler:    _ActionService_DoOrbit_Handler,
		},
		{
			MethodName: "Hold",
			Handler:    _ActionService_Hold_Handler,
		},
		{
			MethodName: "SetActuator",
			Handler:    _ActionService_SetActuator_Handler,
		},
		{
			MethodName: "TransitionToFixedwing",
			Handler:    _ActionService_TransitionToFixedwing_Handler,
		},
		{
			MethodName: "TransitionToMulticopter",
			Handler:    _ActionService_TransitionToMulticopter_Handler,
		},
		{
			MethodName: "GetTakeoffAltitude",
			Handler:    _ActionService_GetTakeoffAltitude_Handler,
		},
		{
			MethodName: "SetTakeoffAltitude",
			Handler:    _ActionService_SetTakeoffAltitude_Handler,
		},
		{
			MethodName: "GetReturnToLaunchAltitude",
			Handler:    _ActionService_GetReturnToLaunchAltitude_Handler,
		},
		{
			MethodName: "SetReturnToLaunchAltitude",
			Handler:    _ActionService_SetReturnToLaunchAltitude_Handler,
		},
		{
			MethodName: "SetCurrentSpeed",
			Handler:    _ActionService_SetCurrentSpeed_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "action.proto",
}
