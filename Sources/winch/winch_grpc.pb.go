// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: winch.proto

package winch

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	WinchService_SubscribeStatus_FullMethodName       = "/mavsdk.rpc.winch.WinchService/SubscribeStatus"
	WinchService_Relax_FullMethodName                 = "/mavsdk.rpc.winch.WinchService/Relax"
	WinchService_RelativeLengthControl_FullMethodName = "/mavsdk.rpc.winch.WinchService/RelativeLengthControl"
	WinchService_RateControl_FullMethodName           = "/mavsdk.rpc.winch.WinchService/RateControl"
	WinchService_Lock_FullMethodName                  = "/mavsdk.rpc.winch.WinchService/Lock"
	WinchService_Deliver_FullMethodName               = "/mavsdk.rpc.winch.WinchService/Deliver"
	WinchService_Hold_FullMethodName                  = "/mavsdk.rpc.winch.WinchService/Hold"
	WinchService_Retract_FullMethodName               = "/mavsdk.rpc.winch.WinchService/Retract"
	WinchService_LoadLine_FullMethodName              = "/mavsdk.rpc.winch.WinchService/LoadLine"
	WinchService_AbandonLine_FullMethodName           = "/mavsdk.rpc.winch.WinchService/AbandonLine"
	WinchService_LoadPayload_FullMethodName           = "/mavsdk.rpc.winch.WinchService/LoadPayload"
)

// WinchServiceClient is the client API for WinchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Allows users to send winch actions, as well as receive status information from winch systems.
type WinchServiceClient interface {
	// Subscribe to 'winch status' updates.
	SubscribeStatus(ctx context.Context, in *SubscribeStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StatusResponse], error)
	// Allow motor to freewheel.
	Relax(ctx context.Context, in *RelaxRequest, opts ...grpc.CallOption) (*RelaxResponse, error)
	// Wind or unwind specified length of line, optionally using specified rate.
	RelativeLengthControl(ctx context.Context, in *RelativeLengthControlRequest, opts ...grpc.CallOption) (*RelativeLengthControlResponse, error)
	// Wind or unwind line at specified rate.
	RateControl(ctx context.Context, in *RateControlRequest, opts ...grpc.CallOption) (*RateControlResponse, error)
	// Perform the locking sequence to relieve motor while in the fully retracted position.
	Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error)
	// Sequence of drop, slow down, touch down, reel up, lock.
	Deliver(ctx context.Context, in *DeliverRequest, opts ...grpc.CallOption) (*DeliverResponse, error)
	// Engage motor and hold current position.
	Hold(ctx context.Context, in *HoldRequest, opts ...grpc.CallOption) (*HoldResponse, error)
	// Return the reel to the fully retracted position.
	Retract(ctx context.Context, in *RetractRequest, opts ...grpc.CallOption) (*RetractResponse, error)
	// Load the reel with line.
	//
	// The winch will calculate the total loaded length and stop when the tension exceeds a threshold.
	LoadLine(ctx context.Context, in *LoadLineRequest, opts ...grpc.CallOption) (*LoadLineResponse, error)
	// Spool out the entire length of the line.
	AbandonLine(ctx context.Context, in *AbandonLineRequest, opts ...grpc.CallOption) (*AbandonLineResponse, error)
	// Spools out just enough to present the hook to the user to load the payload.
	LoadPayload(ctx context.Context, in *LoadPayloadRequest, opts ...grpc.CallOption) (*LoadPayloadResponse, error)
}

type winchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWinchServiceClient(cc grpc.ClientConnInterface) WinchServiceClient {
	return &winchServiceClient{cc}
}

func (c *winchServiceClient) SubscribeStatus(ctx context.Context, in *SubscribeStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StatusResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &WinchService_ServiceDesc.Streams[0], WinchService_SubscribeStatus_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeStatusRequest, StatusResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type WinchService_SubscribeStatusClient = grpc.ServerStreamingClient[StatusResponse]

func (c *winchServiceClient) Relax(ctx context.Context, in *RelaxRequest, opts ...grpc.CallOption) (*RelaxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RelaxResponse)
	err := c.cc.Invoke(ctx, WinchService_Relax_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *winchServiceClient) RelativeLengthControl(ctx context.Context, in *RelativeLengthControlRequest, opts ...grpc.CallOption) (*RelativeLengthControlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RelativeLengthControlResponse)
	err := c.cc.Invoke(ctx, WinchService_RelativeLengthControl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *winchServiceClient) RateControl(ctx context.Context, in *RateControlRequest, opts ...grpc.CallOption) (*RateControlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RateControlResponse)
	err := c.cc.Invoke(ctx, WinchService_RateControl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *winchServiceClient) Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LockResponse)
	err := c.cc.Invoke(ctx, WinchService_Lock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *winchServiceClient) Deliver(ctx context.Context, in *DeliverRequest, opts ...grpc.CallOption) (*DeliverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeliverResponse)
	err := c.cc.Invoke(ctx, WinchService_Deliver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *winchServiceClient) Hold(ctx context.Context, in *HoldRequest, opts ...grpc.CallOption) (*HoldResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HoldResponse)
	err := c.cc.Invoke(ctx, WinchService_Hold_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *winchServiceClient) Retract(ctx context.Context, in *RetractRequest, opts ...grpc.CallOption) (*RetractResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RetractResponse)
	err := c.cc.Invoke(ctx, WinchService_Retract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *winchServiceClient) LoadLine(ctx context.Context, in *LoadLineRequest, opts ...grpc.CallOption) (*LoadLineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadLineResponse)
	err := c.cc.Invoke(ctx, WinchService_LoadLine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *winchServiceClient) AbandonLine(ctx context.Context, in *AbandonLineRequest, opts ...grpc.CallOption) (*AbandonLineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbandonLineResponse)
	err := c.cc.Invoke(ctx, WinchService_AbandonLine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *winchServiceClient) LoadPayload(ctx context.Context, in *LoadPayloadRequest, opts ...grpc.CallOption) (*LoadPayloadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadPayloadResponse)
	err := c.cc.Invoke(ctx, WinchService_LoadPayload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WinchServiceServer is the server API for WinchService service.
// All implementations must embed UnimplementedWinchServiceServer
// for forward compatibility.
//
// Allows users to send winch actions, as well as receive status information from winch systems.
type WinchServiceServer interface {
	// Subscribe to 'winch status' updates.
	SubscribeStatus(*SubscribeStatusRequest, grpc.ServerStreamingServer[StatusResponse]) error
	// Allow motor to freewheel.
	Relax(context.Context, *RelaxRequest) (*RelaxResponse, error)
	// Wind or unwind specified length of line, optionally using specified rate.
	RelativeLengthControl(context.Context, *RelativeLengthControlRequest) (*RelativeLengthControlResponse, error)
	// Wind or unwind line at specified rate.
	RateControl(context.Context, *RateControlRequest) (*RateControlResponse, error)
	// Perform the locking sequence to relieve motor while in the fully retracted position.
	Lock(context.Context, *LockRequest) (*LockResponse, error)
	// Sequence of drop, slow down, touch down, reel up, lock.
	Deliver(context.Context, *DeliverRequest) (*DeliverResponse, error)
	// Engage motor and hold current position.
	Hold(context.Context, *HoldRequest) (*HoldResponse, error)
	// Return the reel to the fully retracted position.
	Retract(context.Context, *RetractRequest) (*RetractResponse, error)
	// Load the reel with line.
	//
	// The winch will calculate the total loaded length and stop when the tension exceeds a threshold.
	LoadLine(context.Context, *LoadLineRequest) (*LoadLineResponse, error)
	// Spool out the entire length of the line.
	AbandonLine(context.Context, *AbandonLineRequest) (*AbandonLineResponse, error)
	// Spools out just enough to present the hook to the user to load the payload.
	LoadPayload(context.Context, *LoadPayloadRequest) (*LoadPayloadResponse, error)
	mustEmbedUnimplementedWinchServiceServer()
}

// UnimplementedWinchServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWinchServiceServer struct{}

func (UnimplementedWinchServiceServer) SubscribeStatus(*SubscribeStatusRequest, grpc.ServerStreamingServer[StatusResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeStatus not implemented")
}
func (UnimplementedWinchServiceServer) Relax(context.Context, *RelaxRequest) (*RelaxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Relax not implemented")
}
func (UnimplementedWinchServiceServer) RelativeLengthControl(context.Context, *RelativeLengthControlRequest) (*RelativeLengthControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RelativeLengthControl not implemented")
}
func (UnimplementedWinchServiceServer) RateControl(context.Context, *RateControlRequest) (*RateControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RateControl not implemented")
}
func (UnimplementedWinchServiceServer) Lock(context.Context, *LockRequest) (*LockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lock not implemented")
}
func (UnimplementedWinchServiceServer) Deliver(context.Context, *DeliverRequest) (*DeliverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deliver not implemented")
}
func (UnimplementedWinchServiceServer) Hold(context.Context, *HoldRequest) (*HoldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Hold not implemented")
}
func (UnimplementedWinchServiceServer) Retract(context.Context, *RetractRequest) (*RetractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retract not implemented")
}
func (UnimplementedWinchServiceServer) LoadLine(context.Context, *LoadLineRequest) (*LoadLineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadLine not implemented")
}
func (UnimplementedWinchServiceServer) AbandonLine(context.Context, *AbandonLineRequest) (*AbandonLineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbandonLine not implemented")
}
func (UnimplementedWinchServiceServer) LoadPayload(context.Context, *LoadPayloadRequest) (*LoadPayloadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadPayload not implemented")
}
func (UnimplementedWinchServiceServer) mustEmbedUnimplementedWinchServiceServer() {}
func (UnimplementedWinchServiceServer) testEmbeddedByValue()                      {}

// UnsafeWinchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WinchServiceServer will
// result in compilation errors.
type UnsafeWinchServiceServer interface {
	mustEmbedUnimplementedWinchServiceServer()
}

func RegisterWinchServiceServer(s grpc.ServiceRegistrar, srv WinchServiceServer) {
	// If the following call pancis, it indicates UnimplementedWinchServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WinchService_ServiceDesc, srv)
}

func _WinchService_SubscribeStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WinchServiceServer).SubscribeStatus(m, &grpc.GenericServerStream[SubscribeStatusRequest, StatusResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type WinchService_SubscribeStatusServer = grpc.ServerStreamingServer[StatusResponse]

func _WinchService_Relax_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelaxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WinchServiceServer).Relax(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WinchService_Relax_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WinchServiceServer).Relax(ctx, req.(*RelaxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WinchService_RelativeLengthControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelativeLengthControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WinchServiceServer).RelativeLengthControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WinchService_RelativeLengthControl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WinchServiceServer).RelativeLengthControl(ctx, req.(*RelativeLengthControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WinchService_RateControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RateControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WinchServiceServer).RateControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WinchService_RateControl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WinchServiceServer).RateControl(ctx, req.(*RateControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WinchService_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WinchServiceServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WinchService_Lock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WinchServiceServer).Lock(ctx, req.(*LockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WinchService_Deliver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeliverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WinchServiceServer).Deliver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WinchService_Deliver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WinchServiceServer).Deliver(ctx, req.(*DeliverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WinchService_Hold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HoldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WinchServiceServer).Hold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WinchService_Hold_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WinchServiceServer).Hold(ctx, req.(*HoldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WinchService_Retract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WinchServiceServer).Retract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WinchService_Retract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WinchServiceServer).Retract(ctx, req.(*RetractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WinchService_LoadLine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadLineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WinchServiceServer).LoadLine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WinchService_LoadLine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WinchServiceServer).LoadLine(ctx, req.(*LoadLineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WinchService_AbandonLine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbandonLineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WinchServiceServer).AbandonLine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WinchService_AbandonLine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WinchServiceServer).AbandonLine(ctx, req.(*AbandonLineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WinchService_LoadPayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadPayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WinchServiceServer).LoadPayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WinchService_LoadPayload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WinchServiceServer).LoadPayload(ctx, req.(*LoadPayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WinchService_ServiceDesc is the grpc.ServiceDesc for WinchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WinchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mavsdk.rpc.winch.WinchService",
	HandlerType: (*WinchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Relax",
			Handler:    _WinchService_Relax_Handler,
		},
		{
			MethodName: "RelativeLengthControl",
			Handler:    _WinchService_RelativeLengthControl_Handler,
		},
		{
			MethodName: "RateControl",
			Handler:    _WinchService_RateControl_Handler,
		},
		{
			MethodName: "Lock",
			Handler:    _WinchService_Lock_Handler,
		},
		{
			MethodName: "Deliver",
			Handler:    _WinchService_Deliver_Handler,
		},
		{
			MethodName: "Hold",
			Handler:    _WinchService_Hold_Handler,
		},
		{
			MethodName: "Retract",
			Handler:    _WinchService_Retract_Handler,
		},
		{
			MethodName: "LoadLine",
			Handler:    _WinchService_LoadLine_Handler,
		},
		{
			MethodName: "AbandonLine",
			Handler:    _WinchService_AbandonLine_Handler,
		},
		{
			MethodName: "LoadPayload",
			Handler:    _WinchService_LoadPayload_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeStatus",
			Handler:       _WinchService_SubscribeStatus_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "winch.proto",
}
