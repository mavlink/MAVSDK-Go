// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: gimbal.proto

package gimbal

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	GimbalService_SetAngles_FullMethodName              = "/mavsdk.rpc.gimbal.GimbalService/SetAngles"
	GimbalService_SetPitchAndYaw_FullMethodName         = "/mavsdk.rpc.gimbal.GimbalService/SetPitchAndYaw"
	GimbalService_SetPitchRateAndYawRate_FullMethodName = "/mavsdk.rpc.gimbal.GimbalService/SetPitchRateAndYawRate"
	GimbalService_SetMode_FullMethodName                = "/mavsdk.rpc.gimbal.GimbalService/SetMode"
	GimbalService_SetRoiLocation_FullMethodName         = "/mavsdk.rpc.gimbal.GimbalService/SetRoiLocation"
	GimbalService_TakeControl_FullMethodName            = "/mavsdk.rpc.gimbal.GimbalService/TakeControl"
	GimbalService_ReleaseControl_FullMethodName         = "/mavsdk.rpc.gimbal.GimbalService/ReleaseControl"
	GimbalService_SubscribeControl_FullMethodName       = "/mavsdk.rpc.gimbal.GimbalService/SubscribeControl"
	GimbalService_SubscribeAttitude_FullMethodName      = "/mavsdk.rpc.gimbal.GimbalService/SubscribeAttitude"
)

// GimbalServiceClient is the client API for GimbalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Provide control over a gimbal.
type GimbalServiceClient interface {
	// Set gimbal roll, pitch and yaw angles.
	//
	// This sets the desired roll, pitch and yaw angles of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually be set to the new angles.
	SetAngles(ctx context.Context, in *SetAnglesRequest, opts ...grpc.CallOption) (*SetAnglesResponse, error)
	// Set gimbal pitch and yaw angles.
	//
	// This sets the desired pitch and yaw angles of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually be set to the new angles.
	SetPitchAndYaw(ctx context.Context, in *SetPitchAndYawRequest, opts ...grpc.CallOption) (*SetPitchAndYawResponse, error)
	// Set gimbal angular rates around pitch and yaw axes.
	//
	// This sets the desired angular rates around pitch and yaw axes of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually reach the angular rate.
	SetPitchRateAndYawRate(ctx context.Context, in *SetPitchRateAndYawRateRequest, opts ...grpc.CallOption) (*SetPitchRateAndYawRateResponse, error)
	// Set gimbal mode.
	//
	// This sets the desired yaw mode of a gimbal.
	// Will return when the command is accepted. However, it might
	// take the gimbal longer to actually be set to the new angles.
	SetMode(ctx context.Context, in *SetModeRequest, opts ...grpc.CallOption) (*SetModeResponse, error)
	// Set gimbal region of interest (ROI).
	//
	// This sets a region of interest that the gimbal will point to.
	// The gimbal will continue to point to the specified region until it
	// receives a new command.
	// The function will return when the command is accepted, however, it might
	// take the gimbal longer to actually rotate to the ROI.
	SetRoiLocation(ctx context.Context, in *SetRoiLocationRequest, opts ...grpc.CallOption) (*SetRoiLocationResponse, error)
	// Take control.
	//
	// There can be only two components in control of a gimbal at any given time.
	// One with "primary" control, and one with "secondary" control. The way the
	// secondary control is implemented is not specified and hence depends on the
	// vehicle.
	//
	// Components are expected to be cooperative, which means that they can
	// override each other and should therefore do it carefully.
	TakeControl(ctx context.Context, in *TakeControlRequest, opts ...grpc.CallOption) (*TakeControlResponse, error)
	// Release control.
	//
	// Release control, such that other components can control the gimbal.
	ReleaseControl(ctx context.Context, in *ReleaseControlRequest, opts ...grpc.CallOption) (*ReleaseControlResponse, error)
	// Subscribe to control status updates.
	//
	// This allows a component to know if it has primary, secondary or
	// no control over the gimbal. Also, it gives the system and component ids
	// of the other components in control (if any).
	SubscribeControl(ctx context.Context, in *SubscribeControlRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ControlResponse], error)
	// Subscribe to attitude updates.
	//
	// This gets you the gimbal's attitude and angular rate.
	SubscribeAttitude(ctx context.Context, in *SubscribeAttitudeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AttitudeResponse], error)
}

type gimbalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGimbalServiceClient(cc grpc.ClientConnInterface) GimbalServiceClient {
	return &gimbalServiceClient{cc}
}

func (c *gimbalServiceClient) SetAngles(ctx context.Context, in *SetAnglesRequest, opts ...grpc.CallOption) (*SetAnglesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetAnglesResponse)
	err := c.cc.Invoke(ctx, GimbalService_SetAngles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) SetPitchAndYaw(ctx context.Context, in *SetPitchAndYawRequest, opts ...grpc.CallOption) (*SetPitchAndYawResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetPitchAndYawResponse)
	err := c.cc.Invoke(ctx, GimbalService_SetPitchAndYaw_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) SetPitchRateAndYawRate(ctx context.Context, in *SetPitchRateAndYawRateRequest, opts ...grpc.CallOption) (*SetPitchRateAndYawRateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetPitchRateAndYawRateResponse)
	err := c.cc.Invoke(ctx, GimbalService_SetPitchRateAndYawRate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) SetMode(ctx context.Context, in *SetModeRequest, opts ...grpc.CallOption) (*SetModeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetModeResponse)
	err := c.cc.Invoke(ctx, GimbalService_SetMode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) SetRoiLocation(ctx context.Context, in *SetRoiLocationRequest, opts ...grpc.CallOption) (*SetRoiLocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetRoiLocationResponse)
	err := c.cc.Invoke(ctx, GimbalService_SetRoiLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) TakeControl(ctx context.Context, in *TakeControlRequest, opts ...grpc.CallOption) (*TakeControlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TakeControlResponse)
	err := c.cc.Invoke(ctx, GimbalService_TakeControl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) ReleaseControl(ctx context.Context, in *ReleaseControlRequest, opts ...grpc.CallOption) (*ReleaseControlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReleaseControlResponse)
	err := c.cc.Invoke(ctx, GimbalService_ReleaseControl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) SubscribeControl(ctx context.Context, in *SubscribeControlRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ControlResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &GimbalService_ServiceDesc.Streams[0], GimbalService_SubscribeControl_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeControlRequest, ControlResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GimbalService_SubscribeControlClient = grpc.ServerStreamingClient[ControlResponse]

func (c *gimbalServiceClient) SubscribeAttitude(ctx context.Context, in *SubscribeAttitudeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AttitudeResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &GimbalService_ServiceDesc.Streams[1], GimbalService_SubscribeAttitude_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeAttitudeRequest, AttitudeResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GimbalService_SubscribeAttitudeClient = grpc.ServerStreamingClient[AttitudeResponse]

// GimbalServiceServer is the server API for GimbalService service.
// All implementations must embed UnimplementedGimbalServiceServer
// for forward compatibility.
//
// Provide control over a gimbal.
type GimbalServiceServer interface {
	// Set gimbal roll, pitch and yaw angles.
	//
	// This sets the desired roll, pitch and yaw angles of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually be set to the new angles.
	SetAngles(context.Context, *SetAnglesRequest) (*SetAnglesResponse, error)
	// Set gimbal pitch and yaw angles.
	//
	// This sets the desired pitch and yaw angles of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually be set to the new angles.
	SetPitchAndYaw(context.Context, *SetPitchAndYawRequest) (*SetPitchAndYawResponse, error)
	// Set gimbal angular rates around pitch and yaw axes.
	//
	// This sets the desired angular rates around pitch and yaw axes of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually reach the angular rate.
	SetPitchRateAndYawRate(context.Context, *SetPitchRateAndYawRateRequest) (*SetPitchRateAndYawRateResponse, error)
	// Set gimbal mode.
	//
	// This sets the desired yaw mode of a gimbal.
	// Will return when the command is accepted. However, it might
	// take the gimbal longer to actually be set to the new angles.
	SetMode(context.Context, *SetModeRequest) (*SetModeResponse, error)
	// Set gimbal region of interest (ROI).
	//
	// This sets a region of interest that the gimbal will point to.
	// The gimbal will continue to point to the specified region until it
	// receives a new command.
	// The function will return when the command is accepted, however, it might
	// take the gimbal longer to actually rotate to the ROI.
	SetRoiLocation(context.Context, *SetRoiLocationRequest) (*SetRoiLocationResponse, error)
	// Take control.
	//
	// There can be only two components in control of a gimbal at any given time.
	// One with "primary" control, and one with "secondary" control. The way the
	// secondary control is implemented is not specified and hence depends on the
	// vehicle.
	//
	// Components are expected to be cooperative, which means that they can
	// override each other and should therefore do it carefully.
	TakeControl(context.Context, *TakeControlRequest) (*TakeControlResponse, error)
	// Release control.
	//
	// Release control, such that other components can control the gimbal.
	ReleaseControl(context.Context, *ReleaseControlRequest) (*ReleaseControlResponse, error)
	// Subscribe to control status updates.
	//
	// This allows a component to know if it has primary, secondary or
	// no control over the gimbal. Also, it gives the system and component ids
	// of the other components in control (if any).
	SubscribeControl(*SubscribeControlRequest, grpc.ServerStreamingServer[ControlResponse]) error
	// Subscribe to attitude updates.
	//
	// This gets you the gimbal's attitude and angular rate.
	SubscribeAttitude(*SubscribeAttitudeRequest, grpc.ServerStreamingServer[AttitudeResponse]) error
	mustEmbedUnimplementedGimbalServiceServer()
}

// UnimplementedGimbalServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGimbalServiceServer struct{}

func (UnimplementedGimbalServiceServer) SetAngles(context.Context, *SetAnglesRequest) (*SetAnglesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAngles not implemented")
}
func (UnimplementedGimbalServiceServer) SetPitchAndYaw(context.Context, *SetPitchAndYawRequest) (*SetPitchAndYawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPitchAndYaw not implemented")
}
func (UnimplementedGimbalServiceServer) SetPitchRateAndYawRate(context.Context, *SetPitchRateAndYawRateRequest) (*SetPitchRateAndYawRateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPitchRateAndYawRate not implemented")
}
func (UnimplementedGimbalServiceServer) SetMode(context.Context, *SetModeRequest) (*SetModeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMode not implemented")
}
func (UnimplementedGimbalServiceServer) SetRoiLocation(context.Context, *SetRoiLocationRequest) (*SetRoiLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRoiLocation not implemented")
}
func (UnimplementedGimbalServiceServer) TakeControl(context.Context, *TakeControlRequest) (*TakeControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TakeControl not implemented")
}
func (UnimplementedGimbalServiceServer) ReleaseControl(context.Context, *ReleaseControlRequest) (*ReleaseControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseControl not implemented")
}
func (UnimplementedGimbalServiceServer) SubscribeControl(*SubscribeControlRequest, grpc.ServerStreamingServer[ControlResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeControl not implemented")
}
func (UnimplementedGimbalServiceServer) SubscribeAttitude(*SubscribeAttitudeRequest, grpc.ServerStreamingServer[AttitudeResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeAttitude not implemented")
}
func (UnimplementedGimbalServiceServer) mustEmbedUnimplementedGimbalServiceServer() {}
func (UnimplementedGimbalServiceServer) testEmbeddedByValue()                       {}

// UnsafeGimbalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GimbalServiceServer will
// result in compilation errors.
type UnsafeGimbalServiceServer interface {
	mustEmbedUnimplementedGimbalServiceServer()
}

func RegisterGimbalServiceServer(s grpc.ServiceRegistrar, srv GimbalServiceServer) {
	// If the following call pancis, it indicates UnimplementedGimbalServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GimbalService_ServiceDesc, srv)
}

func _GimbalService_SetAngles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAnglesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).SetAngles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_SetAngles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).SetAngles(ctx, req.(*SetAnglesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_SetPitchAndYaw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPitchAndYawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).SetPitchAndYaw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_SetPitchAndYaw_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).SetPitchAndYaw(ctx, req.(*SetPitchAndYawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_SetPitchRateAndYawRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPitchRateAndYawRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).SetPitchRateAndYawRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_SetPitchRateAndYawRate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).SetPitchRateAndYawRate(ctx, req.(*SetPitchRateAndYawRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_SetMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).SetMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_SetMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).SetMode(ctx, req.(*SetModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_SetRoiLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRoiLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).SetRoiLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_SetRoiLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).SetRoiLocation(ctx, req.(*SetRoiLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_TakeControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TakeControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).TakeControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_TakeControl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).TakeControl(ctx, req.(*TakeControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_ReleaseControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).ReleaseControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_ReleaseControl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).ReleaseControl(ctx, req.(*ReleaseControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_SubscribeControl_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeControlRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GimbalServiceServer).SubscribeControl(m, &grpc.GenericServerStream[SubscribeControlRequest, ControlResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GimbalService_SubscribeControlServer = grpc.ServerStreamingServer[ControlResponse]

func _GimbalService_SubscribeAttitude_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeAttitudeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GimbalServiceServer).SubscribeAttitude(m, &grpc.GenericServerStream[SubscribeAttitudeRequest, AttitudeResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GimbalService_SubscribeAttitudeServer = grpc.ServerStreamingServer[AttitudeResponse]

// GimbalService_ServiceDesc is the grpc.ServiceDesc for GimbalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GimbalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mavsdk.rpc.gimbal.GimbalService",
	HandlerType: (*GimbalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetAngles",
			Handler:    _GimbalService_SetAngles_Handler,
		},
		{
			MethodName: "SetPitchAndYaw",
			Handler:    _GimbalService_SetPitchAndYaw_Handler,
		},
		{
			MethodName: "SetPitchRateAndYawRate",
			Handler:    _GimbalService_SetPitchRateAndYawRate_Handler,
		},
		{
			MethodName: "SetMode",
			Handler:    _GimbalService_SetMode_Handler,
		},
		{
			MethodName: "SetRoiLocation",
			Handler:    _GimbalService_SetRoiLocation_Handler,
		},
		{
			MethodName: "TakeControl",
			Handler:    _GimbalService_TakeControl_Handler,
		},
		{
			MethodName: "ReleaseControl",
			Handler:    _GimbalService_ReleaseControl_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeControl",
			Handler:       _GimbalService_SubscribeControl_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeAttitude",
			Handler:       _GimbalService_SubscribeAttitude_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "gimbal.proto",
}
