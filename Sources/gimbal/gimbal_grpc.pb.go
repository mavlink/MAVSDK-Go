// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: gimbal.proto

package gimbal

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	GimbalService_SetAngles_FullMethodName              = "/mavsdk.rpc.gimbal.GimbalService/SetAngles"
	GimbalService_SetAngularRates_FullMethodName        = "/mavsdk.rpc.gimbal.GimbalService/SetAngularRates"
	GimbalService_SetRoiLocation_FullMethodName         = "/mavsdk.rpc.gimbal.GimbalService/SetRoiLocation"
	GimbalService_TakeControl_FullMethodName            = "/mavsdk.rpc.gimbal.GimbalService/TakeControl"
	GimbalService_ReleaseControl_FullMethodName         = "/mavsdk.rpc.gimbal.GimbalService/ReleaseControl"
	GimbalService_SubscribeGimbalList_FullMethodName    = "/mavsdk.rpc.gimbal.GimbalService/SubscribeGimbalList"
	GimbalService_SubscribeControlStatus_FullMethodName = "/mavsdk.rpc.gimbal.GimbalService/SubscribeControlStatus"
	GimbalService_GetControlStatus_FullMethodName       = "/mavsdk.rpc.gimbal.GimbalService/GetControlStatus"
	GimbalService_SubscribeAttitude_FullMethodName      = "/mavsdk.rpc.gimbal.GimbalService/SubscribeAttitude"
	GimbalService_GetAttitude_FullMethodName            = "/mavsdk.rpc.gimbal.GimbalService/GetAttitude"
)

// GimbalServiceClient is the client API for GimbalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Provide control over a gimbal.
type GimbalServiceClient interface {
	// Set gimbal roll, pitch and yaw angles.
	//
	// This sets the desired roll, pitch and yaw angles of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually be set to the new angles.
	//
	// Note that the roll angle needs to be set to 0 when send_mode is Once.
	SetAngles(ctx context.Context, in *SetAnglesRequest, opts ...grpc.CallOption) (*SetAnglesResponse, error)
	// Set gimbal angular rates.
	//
	// This sets the desired angular rates around roll, pitch and yaw axes of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually reach the angular rate.
	//
	// Note that the roll angle needs to be set to 0 when send_mode is Once.
	SetAngularRates(ctx context.Context, in *SetAngularRatesRequest, opts ...grpc.CallOption) (*SetAngularRatesResponse, error)
	// Set gimbal region of interest (ROI).
	//
	// This sets a region of interest that the gimbal will point to.
	// The gimbal will continue to point to the specified region until it
	// receives a new command.
	// The function will return when the command is accepted, however, it might
	// take the gimbal longer to actually rotate to the ROI.
	SetRoiLocation(ctx context.Context, in *SetRoiLocationRequest, opts ...grpc.CallOption) (*SetRoiLocationResponse, error)
	// Take control.
	//
	// There can be only two components in control of a gimbal at any given time.
	// One with "primary" control, and one with "secondary" control. The way the
	// secondary control is implemented is not specified and hence depends on the
	// vehicle.
	//
	// Components are expected to be cooperative, which means that they can
	// override each other and should therefore do it carefully.
	TakeControl(ctx context.Context, in *TakeControlRequest, opts ...grpc.CallOption) (*TakeControlResponse, error)
	// Release control.
	//
	// Release control, such that other components can control the gimbal.
	ReleaseControl(ctx context.Context, in *ReleaseControlRequest, opts ...grpc.CallOption) (*ReleaseControlResponse, error)
	// Subscribe to list of gimbals.
	//
	// This allows to find out what gimbals are connected to the system.
	// Based on the gimbal ID, we can then address a specific gimbal.
	SubscribeGimbalList(ctx context.Context, in *SubscribeGimbalListRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GimbalListResponse], error)
	// Subscribe to control status updates.
	//
	// This allows a component to know if it has primary, secondary or
	// no control over the gimbal. Also, it gives the system and component ids
	// of the other components in control (if any).
	SubscribeControlStatus(ctx context.Context, in *SubscribeControlStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ControlStatusResponse], error)
	// Get control status for specific gimbal.
	GetControlStatus(ctx context.Context, in *GetControlStatusRequest, opts ...grpc.CallOption) (*GetControlStatusResponse, error)
	// Subscribe to attitude updates.
	//
	// This gets you the gimbal's attitude and angular rate.
	SubscribeAttitude(ctx context.Context, in *SubscribeAttitudeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AttitudeResponse], error)
	// Get attitude for specific gimbal.
	GetAttitude(ctx context.Context, in *GetAttitudeRequest, opts ...grpc.CallOption) (*GetAttitudeResponse, error)
}

type gimbalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGimbalServiceClient(cc grpc.ClientConnInterface) GimbalServiceClient {
	return &gimbalServiceClient{cc}
}

func (c *gimbalServiceClient) SetAngles(ctx context.Context, in *SetAnglesRequest, opts ...grpc.CallOption) (*SetAnglesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetAnglesResponse)
	err := c.cc.Invoke(ctx, GimbalService_SetAngles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) SetAngularRates(ctx context.Context, in *SetAngularRatesRequest, opts ...grpc.CallOption) (*SetAngularRatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetAngularRatesResponse)
	err := c.cc.Invoke(ctx, GimbalService_SetAngularRates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) SetRoiLocation(ctx context.Context, in *SetRoiLocationRequest, opts ...grpc.CallOption) (*SetRoiLocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetRoiLocationResponse)
	err := c.cc.Invoke(ctx, GimbalService_SetRoiLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) TakeControl(ctx context.Context, in *TakeControlRequest, opts ...grpc.CallOption) (*TakeControlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TakeControlResponse)
	err := c.cc.Invoke(ctx, GimbalService_TakeControl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) ReleaseControl(ctx context.Context, in *ReleaseControlRequest, opts ...grpc.CallOption) (*ReleaseControlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReleaseControlResponse)
	err := c.cc.Invoke(ctx, GimbalService_ReleaseControl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) SubscribeGimbalList(ctx context.Context, in *SubscribeGimbalListRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GimbalListResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &GimbalService_ServiceDesc.Streams[0], GimbalService_SubscribeGimbalList_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeGimbalListRequest, GimbalListResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GimbalService_SubscribeGimbalListClient = grpc.ServerStreamingClient[GimbalListResponse]

func (c *gimbalServiceClient) SubscribeControlStatus(ctx context.Context, in *SubscribeControlStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ControlStatusResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &GimbalService_ServiceDesc.Streams[1], GimbalService_SubscribeControlStatus_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeControlStatusRequest, ControlStatusResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GimbalService_SubscribeControlStatusClient = grpc.ServerStreamingClient[ControlStatusResponse]

func (c *gimbalServiceClient) GetControlStatus(ctx context.Context, in *GetControlStatusRequest, opts ...grpc.CallOption) (*GetControlStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetControlStatusResponse)
	err := c.cc.Invoke(ctx, GimbalService_GetControlStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) SubscribeAttitude(ctx context.Context, in *SubscribeAttitudeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AttitudeResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &GimbalService_ServiceDesc.Streams[2], GimbalService_SubscribeAttitude_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeAttitudeRequest, AttitudeResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GimbalService_SubscribeAttitudeClient = grpc.ServerStreamingClient[AttitudeResponse]

func (c *gimbalServiceClient) GetAttitude(ctx context.Context, in *GetAttitudeRequest, opts ...grpc.CallOption) (*GetAttitudeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAttitudeResponse)
	err := c.cc.Invoke(ctx, GimbalService_GetAttitude_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GimbalServiceServer is the server API for GimbalService service.
// All implementations must embed UnimplementedGimbalServiceServer
// for forward compatibility.
//
// Provide control over a gimbal.
type GimbalServiceServer interface {
	// Set gimbal roll, pitch and yaw angles.
	//
	// This sets the desired roll, pitch and yaw angles of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually be set to the new angles.
	//
	// Note that the roll angle needs to be set to 0 when send_mode is Once.
	SetAngles(context.Context, *SetAnglesRequest) (*SetAnglesResponse, error)
	// Set gimbal angular rates.
	//
	// This sets the desired angular rates around roll, pitch and yaw axes of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually reach the angular rate.
	//
	// Note that the roll angle needs to be set to 0 when send_mode is Once.
	SetAngularRates(context.Context, *SetAngularRatesRequest) (*SetAngularRatesResponse, error)
	// Set gimbal region of interest (ROI).
	//
	// This sets a region of interest that the gimbal will point to.
	// The gimbal will continue to point to the specified region until it
	// receives a new command.
	// The function will return when the command is accepted, however, it might
	// take the gimbal longer to actually rotate to the ROI.
	SetRoiLocation(context.Context, *SetRoiLocationRequest) (*SetRoiLocationResponse, error)
	// Take control.
	//
	// There can be only two components in control of a gimbal at any given time.
	// One with "primary" control, and one with "secondary" control. The way the
	// secondary control is implemented is not specified and hence depends on the
	// vehicle.
	//
	// Components are expected to be cooperative, which means that they can
	// override each other and should therefore do it carefully.
	TakeControl(context.Context, *TakeControlRequest) (*TakeControlResponse, error)
	// Release control.
	//
	// Release control, such that other components can control the gimbal.
	ReleaseControl(context.Context, *ReleaseControlRequest) (*ReleaseControlResponse, error)
	// Subscribe to list of gimbals.
	//
	// This allows to find out what gimbals are connected to the system.
	// Based on the gimbal ID, we can then address a specific gimbal.
	SubscribeGimbalList(*SubscribeGimbalListRequest, grpc.ServerStreamingServer[GimbalListResponse]) error
	// Subscribe to control status updates.
	//
	// This allows a component to know if it has primary, secondary or
	// no control over the gimbal. Also, it gives the system and component ids
	// of the other components in control (if any).
	SubscribeControlStatus(*SubscribeControlStatusRequest, grpc.ServerStreamingServer[ControlStatusResponse]) error
	// Get control status for specific gimbal.
	GetControlStatus(context.Context, *GetControlStatusRequest) (*GetControlStatusResponse, error)
	// Subscribe to attitude updates.
	//
	// This gets you the gimbal's attitude and angular rate.
	SubscribeAttitude(*SubscribeAttitudeRequest, grpc.ServerStreamingServer[AttitudeResponse]) error
	// Get attitude for specific gimbal.
	GetAttitude(context.Context, *GetAttitudeRequest) (*GetAttitudeResponse, error)
	mustEmbedUnimplementedGimbalServiceServer()
}

// UnimplementedGimbalServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGimbalServiceServer struct{}

func (UnimplementedGimbalServiceServer) SetAngles(context.Context, *SetAnglesRequest) (*SetAnglesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAngles not implemented")
}
func (UnimplementedGimbalServiceServer) SetAngularRates(context.Context, *SetAngularRatesRequest) (*SetAngularRatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAngularRates not implemented")
}
func (UnimplementedGimbalServiceServer) SetRoiLocation(context.Context, *SetRoiLocationRequest) (*SetRoiLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRoiLocation not implemented")
}
func (UnimplementedGimbalServiceServer) TakeControl(context.Context, *TakeControlRequest) (*TakeControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TakeControl not implemented")
}
func (UnimplementedGimbalServiceServer) ReleaseControl(context.Context, *ReleaseControlRequest) (*ReleaseControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseControl not implemented")
}
func (UnimplementedGimbalServiceServer) SubscribeGimbalList(*SubscribeGimbalListRequest, grpc.ServerStreamingServer[GimbalListResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeGimbalList not implemented")
}
func (UnimplementedGimbalServiceServer) SubscribeControlStatus(*SubscribeControlStatusRequest, grpc.ServerStreamingServer[ControlStatusResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeControlStatus not implemented")
}
func (UnimplementedGimbalServiceServer) GetControlStatus(context.Context, *GetControlStatusRequest) (*GetControlStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetControlStatus not implemented")
}
func (UnimplementedGimbalServiceServer) SubscribeAttitude(*SubscribeAttitudeRequest, grpc.ServerStreamingServer[AttitudeResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeAttitude not implemented")
}
func (UnimplementedGimbalServiceServer) GetAttitude(context.Context, *GetAttitudeRequest) (*GetAttitudeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAttitude not implemented")
}
func (UnimplementedGimbalServiceServer) mustEmbedUnimplementedGimbalServiceServer() {}
func (UnimplementedGimbalServiceServer) testEmbeddedByValue()                       {}

// UnsafeGimbalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GimbalServiceServer will
// result in compilation errors.
type UnsafeGimbalServiceServer interface {
	mustEmbedUnimplementedGimbalServiceServer()
}

func RegisterGimbalServiceServer(s grpc.ServiceRegistrar, srv GimbalServiceServer) {
	// If the following call pancis, it indicates UnimplementedGimbalServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GimbalService_ServiceDesc, srv)
}

func _GimbalService_SetAngles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAnglesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).SetAngles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_SetAngles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).SetAngles(ctx, req.(*SetAnglesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_SetAngularRates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAngularRatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).SetAngularRates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_SetAngularRates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).SetAngularRates(ctx, req.(*SetAngularRatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_SetRoiLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRoiLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).SetRoiLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_SetRoiLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).SetRoiLocation(ctx, req.(*SetRoiLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_TakeControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TakeControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).TakeControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_TakeControl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).TakeControl(ctx, req.(*TakeControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_ReleaseControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).ReleaseControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_ReleaseControl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).ReleaseControl(ctx, req.(*ReleaseControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_SubscribeGimbalList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeGimbalListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GimbalServiceServer).SubscribeGimbalList(m, &grpc.GenericServerStream[SubscribeGimbalListRequest, GimbalListResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GimbalService_SubscribeGimbalListServer = grpc.ServerStreamingServer[GimbalListResponse]

func _GimbalService_SubscribeControlStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeControlStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GimbalServiceServer).SubscribeControlStatus(m, &grpc.GenericServerStream[SubscribeControlStatusRequest, ControlStatusResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GimbalService_SubscribeControlStatusServer = grpc.ServerStreamingServer[ControlStatusResponse]

func _GimbalService_GetControlStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetControlStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).GetControlStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_GetControlStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).GetControlStatus(ctx, req.(*GetControlStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_SubscribeAttitude_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeAttitudeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GimbalServiceServer).SubscribeAttitude(m, &grpc.GenericServerStream[SubscribeAttitudeRequest, AttitudeResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GimbalService_SubscribeAttitudeServer = grpc.ServerStreamingServer[AttitudeResponse]

func _GimbalService_GetAttitude_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAttitudeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).GetAttitude(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GimbalService_GetAttitude_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).GetAttitude(ctx, req.(*GetAttitudeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GimbalService_ServiceDesc is the grpc.ServiceDesc for GimbalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GimbalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mavsdk.rpc.gimbal.GimbalService",
	HandlerType: (*GimbalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetAngles",
			Handler:    _GimbalService_SetAngles_Handler,
		},
		{
			MethodName: "SetAngularRates",
			Handler:    _GimbalService_SetAngularRates_Handler,
		},
		{
			MethodName: "SetRoiLocation",
			Handler:    _GimbalService_SetRoiLocation_Handler,
		},
		{
			MethodName: "TakeControl",
			Handler:    _GimbalService_TakeControl_Handler,
		},
		{
			MethodName: "ReleaseControl",
			Handler:    _GimbalService_ReleaseControl_Handler,
		},
		{
			MethodName: "GetControlStatus",
			Handler:    _GimbalService_GetControlStatus_Handler,
		},
		{
			MethodName: "GetAttitude",
			Handler:    _GimbalService_GetAttitude_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeGimbalList",
			Handler:       _GimbalService_SubscribeGimbalList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeControlStatus",
			Handler:       _GimbalService_SubscribeControlStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeAttitude",
			Handler:       _GimbalService_SubscribeAttitude_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "gimbal.proto",
}
